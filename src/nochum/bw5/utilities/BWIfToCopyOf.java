package nochum.bw5.utilities;
import java.io.File;
import java.io.IOException;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * We often see a construct similar to the following if we examine BW process
 * files in a test editor:
 * <p>
 *     <xsl:if test="pfx10:ContactFrequency">
 *         <pfx10:ContactFrequency>
 *              <xsl:value-of select="pfx10:ContactFrequency"/>
 *         </pfx10:ContactFrequency>
 *     </xsl:if>
 * <p>
 * The 'if' statement surrounding the actual mapping is often generated by
 * Designer as the result of an optional-to-optional mapping.  Where the 
 * value is being passed unchanged, the same result can be delivered much
 * more succinctly with the following construct instead:
 * <p>
 *     <xsl:copy-of select="pfx10:ContactFrequency"/>
 * <p>
 * This will copy the value if it exists in the source data.  Otherwise it
 * should not produce an output element.  While this may seem like a "trivial"
 * savings, where large XML documents are being mapped the actual savings can
 * be significant.
 * <p>
 * It is important to note that the space savings that we see on disk does not
 * necessarily translate to in-memory savings.  When processing large XML
 * documents most of the memory consumption may end up being the actual 
 * transient data being passed and manipulated rather than the mappings.  So
 * if the goal is to reduce memory utilization it may be best to consider ways
 * that a large XML document can be broken down into smaller chunks so that
 * the entire document does not need to be in memory at once.
 * 
 * @author Nochum Klein
 * @version %I%, %G%
 */ 
class BWIfToCopyOf {
	
	/**
	 * 
	 */
	private Document   doc           = null;  
	/**
	 * The properties required to invoke Hawk and traverse the project filesystem
	 */
	private Properties _props = null;
	
	/**
	 * Class constructor triggers all processing and signals completion.
	 * @param props                           the properties collected by the Optimize facade class.
	 * @throws UsageException                 if required options are missing or invalid
	 * @throws ParserConfigurationException   If errors are incurred parsing the BW process.
	 * @throws IOException                    If errors are incurred parsing the BW process.
	 * @throws SAXException                   If errors are incurred parsing the BW process.
	 */
	public BWIfToCopyOf(Properties props) throws TransformerException, SAXException, IOException, ParserConfigurationException, UsageException {
		final String usageString = "\nUsage: Optimize ifToCopyOf [options]\n\n" +
				"   where options are:\n\n" +
				"-project   <project location>   - Full path to project on the filesystem.\n"
				;

		// set the props class variable
		_props = props;
		
		if (!_props.containsKey("projectRoot")) {
			throw(new UsageException("Required input parameter '-project' has not been specified.", usageString));
		}
		
		traverse(new File(_props.getProperty("projectRoot")));
	}

    /**
     * Works on a single file system entry and
     * calls itself recursively if it turns out
     * to be a directory.
     * @param file A file or a directory to process
	 * @throws IOException 
	 * @throws SAXException 
	 * @throws ParserConfigurationException 
	 */
	private void traverse( File file ) throws TransformerException, SAXException, IOException, ParserConfigurationException {
       // Print the name of the entry
//       System.out.println( file.getName() ) ;

       // Check if it is a directory
       if( file.isDirectory() ) {
          // Get a list of all the entries in the directory
          String entries[] = file.list() ;

          // Ensure that the list is not null
          if( entries != null ) {
             // Loop over all the entries
             for( String entry : entries ) {
                // Recursive call to traverse
                traverse( new File(file,entry) ) ;
             }
          }
       } else {
    	   if (file.getName().endsWith(".process")) {
    		   processBWProcess(file);
    	   }
       }
	}
	
	/**
	 * recursively process each activity input
	 * @param bwProcess
	 * @throws TransformerException 
	 * @throws IOException 
	 * @throws SAXException 
	 * @throws ParserConfigurationException 
	 */
	private void processBWProcess(File bwProcess) throws TransformerException, SAXException, IOException, ParserConfigurationException  {
		DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		doc = dBuilder.parse(bwProcess);

		doc.getDocumentElement().normalize();

		// Retrieve the set of activities within the BW process
		NodeList activityList = doc.getElementsByTagName("pd:activity");

		for (int i = 0; i < activityList.getLength(); i++) {

			Node activity = activityList.item(i);
			if (activity.getNodeType() == Node.ELEMENT_NODE) {

				Element eActivity = (Element) activity;
				
				Node inputBindings = eActivity.getElementsByTagName("pd:inputBindings").item(0);
				
				// Here I want to get the first child node and recursively process it to completion.
				processActivityInput(getChildElementNode(inputBindings));
			}
		}
		
		// write the DOM object back to the BW process file
		TransformerFactory transformerFactory = TransformerFactory.newInstance();
		Transformer transformer = transformerFactory.newTransformer();
		DOMSource domSource = new DOMSource(doc);

		StreamResult streamResult = new StreamResult(bwProcess);
		transformer.transform(domSource, streamResult);
	}

	/*
	 * core processing happens here.  We evaluate whether the node is a
	 * candidate for replacement.  If it is we replace it, otherwise we
	 * continue processing recursively.
	 *   
	 * A picture is worth 1000 words.  We are trying to change the following
	 * into a single-line copy-of:
	 *     <xsl:if test="pfx10:ContactFrequency">
	 *         <pfx10:ContactFrequency>
	 *              <xsl:value-of select="pfx10:ContactFrequency"/>
	 *         </pfx10:ContactFrequency>
	 *     </xsl:if>
	 */
	/**
	 * @param node
	 */
	private void processActivityInput(Node node) {
        
		if ( (node != null) && (node.getNodeType() == Node.ELEMENT_NODE) ) {
			String nodeName = node.getNodeName();

			// <xsl:if test="pfx10:ContactFrequency">
			String testValue = null;
			if (nodeName.equals("xsl:if") && node.hasAttributes()) {
				testValue = node.getAttributes().getNamedItem("test").getNodeValue();
				System.out.println("\t"+ testValue);
			}

			// <pfx10:ContactFrequency>
			NodeList childNodes = null;
			Node childNode = null;
			int childNodeCount = 0;
			if (node.hasChildNodes()) {
				childNodes = node.getChildNodes();
				for (int i = 0; i < childNodes.getLength(); i++) {
					Node currNode = childNodes.item(i);
					if (currNode.getNodeType() == Node.ELEMENT_NODE) {
						childNodeCount++;
						if (childNode == null)
							childNode = currNode;
					}
				}
			}

			// <xsl:value-of select="pfx10:ContactFrequency"/>
			NodeList grandchildNodes = null;
			Node grandchildNode = null;
			int grandchildNodeCount = 0;
			if ((childNode != null) && (childNode.hasChildNodes())) {
				grandchildNodes = childNode.getChildNodes();
				for (int i = 0; i < grandchildNodes.getLength(); i++) {
					Node currNode = grandchildNodes.item(i);
					if (currNode.getNodeType() == Node.ELEMENT_NODE) {
						grandchildNodeCount++;
						if (grandchildNode == null)
							grandchildNode = currNode;
					}
				}
			}

			String selectValue = null;
			if ((grandchildNode != null) && grandchildNode.getNodeName().equals("xsl:value-of") && grandchildNode.hasAttributes())
				selectValue = grandchildNode.getAttributes().getNamedItem("select").getNodeValue();

			if (testValue != null && 
					childNode != null &&
					childNodeCount == 1 &&
					childNode.getNodeName().equals(testValue) &&
					grandchildNode != null &&
					grandchildNodeCount == 1 &&
					grandchildNode.getNodeName().equals("xsl:value-of") &&
					selectValue != null &&
					selectValue.equals(testValue)) {
				
//				System.out.println("\t"+testValue);

				Element newElem = doc.createElement("xsl:copy-of");
				newElem.setAttribute("select", testValue);

				Node parentNode = node.getParentNode();
				parentNode.replaceChild(newElem, node);
			} else if (childNodes != null) {
				// process children recursively
				for (int i = 0; i < childNodes.getLength(); i++) {
					processActivityInput(childNodes.item(i));
				}
			}
		}
		
		return;
	}
	
	/**
     * Returns a first child DOM Node of type ELEMENT_NODE
     * for the specified Node.
     * @param xmlNode
     * @return
     */
    private static Node getChildElementNode(Node xmlNode) {
        if (xmlNode == null || !xmlNode.hasChildNodes()) {
            return null;
        }
        
        xmlNode = xmlNode.getFirstChild();
        while (xmlNode != null 
               && xmlNode.getNodeType() != Node.ELEMENT_NODE) {
            xmlNode = xmlNode.getNextSibling();
        }

        return xmlNode;
    }
}